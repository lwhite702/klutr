{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/lib/posthog/api.ts"],"sourcesContent":["/**\n * PostHog REST API Client\n * \n * Provides functions to manage PostHog resources via REST API.\n * Requires Personal API Key (not project API key) for management operations.\n */\n\ninterface CreateFeatureFlagOptions {\n  key: string;\n  name: string;\n  description?: string;\n  active?: boolean;\n  filters?: {\n    groups?: Array<{\n      properties?: Array<{\n        key: string;\n        value: string | number | boolean;\n        operator?: string;\n      }>;\n      rollout_percentage?: number;\n    }>;\n  };\n  ensure_unique?: boolean; // If true, will not create if flag already exists\n}\n\ninterface FeatureFlagResponse {\n  id: number;\n  key: string;\n  name: string;\n  active: boolean;\n  created_at: string;\n  created_by?: {\n    id: number;\n    email: string;\n  };\n}\n\n/**\n * Get PostHog API configuration\n */\nfunction getApiConfig() {\n  const personalApiKey = process.env.POSTHOG_PERSONAL_API_KEY;\n  const host = process.env.NEXT_PUBLIC_POSTHOG_HOST || \"https://us.posthog.com\";\n  const projectId = process.env.POSTHOG_PROJECT_ID;\n\n  if (!personalApiKey) {\n    throw new Error(\n      \"POSTHOG_PERSONAL_API_KEY is required for API operations. \" +\n      \"Get it from PostHog → Settings → Personal API Keys\"\n    );\n  }\n\n  if (!projectId) {\n    throw new Error(\n      \"POSTHOG_PROJECT_ID is required. \" +\n      \"Get it from PostHog → Project Settings\"\n    );\n  }\n\n  return { personalApiKey, host, projectId };\n}\n\n/**\n * Create a feature flag in PostHog\n * @param options - Feature flag configuration\n * @returns Promise that resolves to the created feature flag\n */\nexport async function createFeatureFlag(\n  options: CreateFeatureFlagOptions\n): Promise<FeatureFlagResponse> {\n  const { personalApiKey, host, projectId } = getApiConfig();\n\n  const url = `${host}/api/projects/${projectId}/feature_flags/`;\n  \n  const payload: any = {\n    key: options.key,\n    name: options.name,\n    active: options.active ?? false,\n  };\n\n  if (options.description) {\n    payload.description = options.description;\n  }\n\n  if (options.filters) {\n    payload.filters = options.filters;\n  }\n\n  // If ensure_unique is true, check if flag exists first\n  if (options.ensure_unique) {\n    try {\n      const existing = await getFeatureFlag(options.key);\n      if (existing) {\n        console.log(`[PostHog API] Feature flag \"${options.key}\" already exists, skipping creation`);\n        return existing;\n      }\n    } catch (error) {\n      // Flag doesn't exist, continue with creation\n    }\n  }\n\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${personalApiKey}`,\n      },\n      body: JSON.stringify(payload),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `PostHog API error (${response.status}): ${errorText}`\n      );\n    }\n\n    const data = await response.json();\n    console.log(`[PostHog API] Created feature flag: ${options.key}`);\n    return data;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to create feature flag: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Get a feature flag by key\n * @param key - Feature flag key\n * @returns Promise that resolves to the feature flag or null if not found\n */\nexport async function getFeatureFlag(\n  key: string\n): Promise<FeatureFlagResponse | null> {\n  const { personalApiKey, host, projectId } = getApiConfig();\n\n  const url = `${host}/api/projects/${projectId}/feature_flags/${key}/`;\n\n  try {\n    const response = await fetch(url, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${personalApiKey}`,\n      },\n    });\n\n    if (response.status === 404) {\n      return null;\n    }\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `PostHog API error (${response.status}): ${errorText}`\n      );\n    }\n\n    return await response.json();\n  } catch (error) {\n    if (error instanceof Error && error.message.includes(\"404\")) {\n      return null;\n    }\n    throw error;\n  }\n}\n\n/**\n * Update a feature flag\n * @param key - Feature flag key\n * @param updates - Partial feature flag updates\n * @returns Promise that resolves to the updated feature flag\n */\nexport async function updateFeatureFlag(\n  key: string,\n  updates: Partial<CreateFeatureFlagOptions>\n): Promise<FeatureFlagResponse> {\n  const { personalApiKey, host, projectId } = getApiConfig();\n\n  const url = `${host}/api/projects/${projectId}/feature_flags/${key}/`;\n\n  try {\n    const response = await fetch(url, {\n      method: \"PATCH\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${personalApiKey}`,\n      },\n      body: JSON.stringify(updates),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(\n        `PostHog API error (${response.status}): ${errorText}`\n      );\n    }\n\n    const data = await response.json();\n    console.log(`[PostHog API] Updated feature flag: ${key}`);\n    return data;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to update feature flag: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Delete a feature flag\n * @param key - Feature flag key\n */\nexport async function deleteFeatureFlag(key: string): Promise<void> {\n  const { personalApiKey, host, projectId } = getApiConfig();\n\n  const url = `${host}/api/projects/${projectId}/feature_flags/${key}/`;\n\n  try {\n    const response = await fetch(url, {\n      method: \"DELETE\",\n      headers: {\n        Authorization: `Bearer ${personalApiKey}`,\n      },\n    });\n\n    if (!response.ok && response.status !== 404) {\n      const errorText = await response.text();\n      throw new Error(\n        `PostHog API error (${response.status}): ${errorText}`\n      );\n    }\n\n    console.log(`[PostHog API] Deleted feature flag: ${key}`);\n  } catch (error) {\n    if (error instanceof Error) {\n      throw new Error(`Failed to delete feature flag: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Create all default feature flags for the app\n * This creates the flags defined in FEATURE_FLAGS if they don't exist\n */\nexport async function createDefaultFeatureFlags(): Promise<void> {\n  const { FEATURE_FLAGS } = await import(\"@/lib/featureFlags\");\n\n  const defaultFlags = [\n    {\n      key: FEATURE_FLAGS.SPARK_BETA,\n      name: \"Spark Beta\",\n      description: \"Beta access to Spark feature\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.MUSE_AI,\n      name: \"Muse AI\",\n      description: \"Muse AI feature access\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.ORBIT_EXPERIMENTAL,\n      name: \"Orbit Experimental\",\n      description: \"Experimental Orbit view feature\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.VAULT_ENHANCED,\n      name: \"Vault Enhanced\",\n      description: \"Enhanced vault features\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.KLUTR_GLOBAL_DISABLE,\n      name: \"Klutr Global Disable\",\n      description: \"Global kill switch - disables all experimental features when enabled\",\n      active: false,\n    },\n  ];\n\n  console.log(\"[PostHog API] Creating default feature flags...\");\n\n  for (const flag of defaultFlags) {\n    try {\n      await createFeatureFlag({\n        ...flag,\n        ensure_unique: true, // Skip if already exists\n      });\n    } catch (error) {\n      console.error(`[PostHog API] Failed to create flag \"${flag.key}\":`, error);\n    }\n  }\n\n  console.log(\"[PostHog API] Finished creating default feature flags\");\n}\n\n"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 254, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/lib/posthog/client.ts"],"sourcesContent":["/**\n * PostHog Client-Side Integration\n * \n * Provides singleton PostHog client instance for browser-side analytics and feature flags.\n * Initializes only on client-side to avoid SSR issues.\n */\n\nimport posthog from \"posthog-js\";\n\nlet posthogClient: typeof posthog | null = null;\nlet isInitialized = false;\nlet initPromise: Promise<void> | null = null;\n\n/**\n * Initialize PostHog client (singleton pattern)\n * Only initializes once, even if called multiple times\n */\nexport function initPostHog(): void {\n  // Only initialize on client-side\n  if (typeof window === \"undefined\") {\n    return;\n  }\n\n  // Return if already initialized\n  if (isInitialized && posthogClient) {\n    return;\n  }\n\n  // If initialization is in progress, return the existing promise\n  if (initPromise) {\n    return;\n  }\n\n  const apiKey = process.env.NEXT_PUBLIC_POSTHOG_KEY;\n  const apiHost = process.env.NEXT_PUBLIC_POSTHOG_HOST || \"https://us.posthog.com\";\n\n  if (!apiKey) {\n    console.warn(\"[PostHog] NEXT_PUBLIC_POSTHOG_KEY is not set. PostHog will not be initialized.\");\n    return;\n  }\n\n  // Initialize PostHog\n  posthog.init(apiKey, {\n    api_host: \"/ingest\", // Use Next.js rewrite proxy\n    ui_host: apiHost,\n    capture_exceptions: true,\n    debug: process.env.NODE_ENV === \"development\",\n    loaded: (posthog) => {\n      posthogClient = posthog;\n      isInitialized = true;\n    },\n  });\n\n  posthogClient = posthog;\n}\n\n/**\n * Get PostHog client instance\n * Returns null if not initialized or on server-side\n */\nexport function getPostHogClient(): typeof posthog | null {\n  if (typeof window === \"undefined\") {\n    return null;\n  }\n\n  if (!isInitialized) {\n    initPostHog();\n  }\n\n  return posthogClient;\n}\n\n/**\n * Identify a user in PostHog\n * @param userId - User ID (typically Supabase user.id)\n * @param email - User email (optional)\n * @param properties - Additional user properties (optional)\n */\nexport function identifyUser(\n  userId: string,\n  email?: string,\n  properties?: Record<string, any>\n): void {\n  const client = getPostHogClient();\n  if (!client) {\n    return;\n  }\n\n  client.identify(userId, {\n    email,\n    ...properties,\n  });\n}\n\n/**\n * Reset user identification (call on logout)\n */\nexport function resetUser(): void {\n  const client = getPostHogClient();\n  if (!client) {\n    return;\n  }\n\n  client.reset();\n}\n\n/**\n * Check if a feature flag is enabled\n * Waits for PostHog to be ready before checking flags\n * @param flag - Feature flag key\n * @returns Promise that resolves to true if flag is enabled, false otherwise\n */\nexport async function isFeatureEnabled(flag: string): Promise<boolean> {\n  const client = getPostHogClient();\n  if (!client) {\n    return false;\n  }\n\n  // Wait for PostHog to be ready\n  return new Promise((resolve) => {\n    // Use onFeatureFlags callback to ensure flags are loaded\n    client!.onFeatureFlags(() => {\n      const enabled = client!.isFeatureEnabled(flag);\n      resolve(enabled ?? false);\n    });\n  });\n}\n\n/**\n * Get feature flag value (for multivariate flags)\n * @param flag - Feature flag key\n * @returns Promise that resolves to the flag value or null\n */\nexport async function getFeatureFlag(flag: string): Promise<string | boolean | null> {\n  const client = getPostHogClient();\n  if (!client) {\n    return null;\n  }\n\n  return new Promise((resolve) => {\n    client!.onFeatureFlags(() => {\n      const value = client!.getFeatureFlag(flag);\n      resolve(value ?? null);\n    });\n  });\n}\n\n/**\n * Get feature flag payload (for JSON payloads)\n * @param flag - Feature flag key\n * @returns Promise that resolves to the flag payload or null\n */\nexport async function getFeatureFlagPayload(flag: string): Promise<any> {\n  const client = getPostHogClient();\n  if (!client) {\n    return null;\n  }\n\n  return new Promise((resolve) => {\n    client!.onFeatureFlags(() => {\n      const payload = client!.getFeatureFlagPayload(flag);\n      resolve(payload ?? null);\n    });\n  });\n}\n\n/**\n * Reload feature flags from PostHog\n * Useful after user identification or when flags need to be refreshed\n */\nexport function reloadFeatureFlags(): void {\n  const client = getPostHogClient();\n  if (!client) {\n    return;\n  }\n\n  client.reloadFeatureFlags();\n}\n\n/**\n * Capture an event in PostHog\n * @param eventName - Event name\n * @param properties - Event properties (optional)\n */\nexport function captureEvent(eventName: string, properties?: Record<string, any>): void {\n  const client = getPostHogClient();\n  if (!client) {\n    return;\n  }\n\n  client.capture(eventName, properties);\n}\n\n// Auto-initialize on module load (client-side only)\nif (typeof window !== \"undefined\") {\n  initPostHog();\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;;;;;;;;;AAED;;AAEA,IAAI,gBAAuC;AAC3C,IAAI,gBAAgB;AACpB,IAAI,cAAoC;AAMjC,SAAS;IACd,iCAAiC;IACjC,wCAAmC;QACjC;IACF;;;IAYA,MAAM;IACN,MAAM;AAoBR;AAMO,SAAS;IACd,wCAAmC;QACjC,OAAO;IACT;;;AAOF;AAQO,SAAS,aACd,MAAc,EACd,KAAc,EACd,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,OAAO,QAAQ,CAAC,QAAQ;QACtB;QACA,GAAG,UAAU;IACf;AACF;AAKO,SAAS;IACd,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,OAAO,KAAK;AACd;AAQO,eAAe,iBAAiB,IAAY;IACjD,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,+BAA+B;IAC/B,OAAO,IAAI,QAAQ,CAAC;QAClB,yDAAyD;QACzD,OAAQ,cAAc,CAAC;YACrB,MAAM,UAAU,OAAQ,gBAAgB,CAAC;YACzC,QAAQ,WAAW;QACrB;IACF;AACF;AAOO,eAAe,eAAe,IAAY;IAC/C,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,OAAO,IAAI,QAAQ,CAAC;QAClB,OAAQ,cAAc,CAAC;YACrB,MAAM,QAAQ,OAAQ,cAAc,CAAC;YACrC,QAAQ,SAAS;QACnB;IACF;AACF;AAOO,eAAe,sBAAsB,IAAY;IACtD,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,OAAO,IAAI,QAAQ,CAAC;QAClB,OAAQ,cAAc,CAAC;YACrB,MAAM,UAAU,OAAQ,qBAAqB,CAAC;YAC9C,QAAQ,WAAW;QACrB;IACF;AACF;AAMO,SAAS;IACd,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,OAAO,kBAAkB;AAC3B;AAOO,SAAS,aAAa,SAAiB,EAAE,UAAgC;IAC9E,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,OAAO,OAAO,CAAC,WAAW;AAC5B;AAEA,oDAAoD;AACpD","debugId":null}},
    {"offset": {"line": 395, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/lib/posthog/server.ts"],"sourcesContent":["/**\n * PostHog Server-Side Integration\n * \n * Provides PostHog Node client for server-side feature flag checks.\n * Used in API routes, server components, and background jobs.\n */\n\nimport { PostHog } from \"posthog-node\";\n\nlet posthogServer: PostHog | null = null;\n\n/**\n * Get or initialize PostHog server client (singleton pattern)\n * @returns PostHog client instance or null if not configured\n */\nfunction getPostHogServer(): PostHog | null {\n  // Return existing instance if already initialized\n  if (posthogServer) {\n    return posthogServer;\n  }\n\n  const apiKey = process.env.POSTHOG_SERVER_KEY;\n  const host = process.env.NEXT_PUBLIC_POSTHOG_HOST || \"https://us.posthog.com\";\n\n  if (!apiKey) {\n    console.warn(\"[PostHog Server] POSTHOG_SERVER_KEY is not set. Server-side feature flags will be disabled.\");\n    return null;\n  }\n\n  try {\n    posthogServer = new PostHog(apiKey, {\n      host,\n      flushAt: 20, // Flush after 20 events\n      flushInterval: 10000, // Flush every 10 seconds\n    });\n\n    return posthogServer;\n  } catch (error) {\n    console.error(\"[PostHog Server] Failed to initialize:\", error);\n    return null;\n  }\n}\n\n/**\n * Check if a feature flag is enabled for a user\n * @param flag - Feature flag key\n * @param distinctId - User distinct ID (typically user.id or email)\n * @param properties - Additional user properties for flag evaluation (optional)\n * @returns Promise that resolves to true if flag is enabled, false otherwise\n */\nexport async function getFeatureFlag(\n  flag: string,\n  distinctId?: string,\n  properties?: Record<string, any>\n): Promise<boolean> {\n  const client = getPostHogServer();\n  if (!client) {\n    // Fail closed: return false if PostHog is not configured\n    return false;\n  }\n\n  try {\n    // Use a default distinct ID if none provided\n    const userId = distinctId || \"anonymous\";\n\n    const isEnabled = await client.isFeatureEnabled(flag, userId, properties);\n    return isEnabled ?? false;\n  } catch (error) {\n    console.error(`[PostHog Server] Error checking feature flag \"${flag}\":`, error);\n    // Fail closed: return false on error\n    return false;\n  }\n}\n\n/**\n * Get feature flag value (for multivariate flags)\n * @param flag - Feature flag key\n * @param distinctId - User distinct ID (typically user.id or email)\n * @param properties - Additional user properties for flag evaluation (optional)\n * @returns Promise that resolves to the flag value or null\n */\nexport async function getFeatureFlagValue(\n  flag: string,\n  distinctId?: string,\n  properties?: Record<string, any>\n): Promise<string | boolean | null> {\n  const client = getPostHogServer();\n  if (!client) {\n    return null;\n  }\n\n  try {\n    const userId = distinctId || \"anonymous\";\n    const value = await client.getFeatureFlag(flag, userId, properties);\n    return value ?? null;\n  } catch (error) {\n    console.error(`[PostHog Server] Error getting feature flag value \"${flag}\":`, error);\n    return null;\n  }\n}\n\n/**\n * Get feature flag payload (for JSON payloads)\n * @param flag - Feature flag key\n * @param distinctId - User distinct ID (typically user.id or email)\n * @param properties - Additional user properties for flag evaluation (optional)\n * @returns Promise that resolves to the flag payload or null\n */\nexport async function getFeatureFlagPayload(\n  flag: string,\n  distinctId?: string,\n  properties?: Record<string, any>\n): Promise<any> {\n  const client = getPostHogServer();\n  if (!client) {\n    return null;\n  }\n\n  try {\n    const userId = distinctId || \"anonymous\";\n    const payload = await client.getFeatureFlagPayload(flag, userId, properties);\n    return payload ?? null;\n  } catch (error) {\n    console.error(`[PostHog Server] Error getting feature flag payload \"${flag}\":`, error);\n    return null;\n  }\n}\n\n/**\n * Capture an event server-side\n * @param distinctId - User distinct ID\n * @param eventName - Event name\n * @param properties - Event properties (optional)\n */\nexport function captureEvent(\n  distinctId: string,\n  eventName: string,\n  properties?: Record<string, any>\n): void {\n  const client = getPostHogServer();\n  if (!client) {\n    return;\n  }\n\n  try {\n    client.capture({\n      distinctId,\n      event: eventName,\n      properties,\n    });\n  } catch (error) {\n    console.error(`[PostHog Server] Error capturing event \"${eventName}\":`, error);\n  }\n}\n\n/**\n * Identify a user server-side\n * @param distinctId - User distinct ID\n * @param properties - User properties (optional)\n */\nexport function identifyUser(\n  distinctId: string,\n  properties?: Record<string, any>\n): void {\n  const client = getPostHogServer();\n  if (!client) {\n    return;\n  }\n\n  try {\n    client.identify({\n      distinctId,\n      properties,\n    });\n  } catch (error) {\n    console.error(`[PostHog Server] Error identifying user \"${distinctId}\":`, error);\n  }\n}\n\n/**\n * Shutdown PostHog server client\n * Call this when shutting down the server (e.g., in cleanup handlers)\n */\nexport async function shutdown(): Promise<void> {\n  if (posthogServer) {\n    await posthogServer.shutdown();\n    posthogServer = null;\n  }\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;;;;;AAED;;AAEA,IAAI,gBAAgC;AAEpC;;;CAGC,GACD,SAAS;IACP,kDAAkD;IAClD,IAAI,eAAe;QACjB,OAAO;IACT;IAEA,MAAM,SAAS,QAAQ,GAAG,CAAC,kBAAkB;IAC7C,MAAM,OAAO,gEAAwC;IAErD,IAAI,CAAC,QAAQ;QACX,QAAQ,IAAI,CAAC;QACb,OAAO;IACT;IAEA,IAAI;QACF,gBAAgB,IAAI,kQAAO,CAAC,QAAQ;YAClC;YACA,SAAS;YACT,eAAe;QACjB;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0CAA0C;QACxD,OAAO;IACT;AACF;AASO,eAAe,eACpB,IAAY,EACZ,UAAmB,EACnB,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,yDAAyD;QACzD,OAAO;IACT;IAEA,IAAI;QACF,6CAA6C;QAC7C,MAAM,SAAS,cAAc;QAE7B,MAAM,YAAY,MAAM,OAAO,gBAAgB,CAAC,MAAM,QAAQ;QAC9D,OAAO,aAAa;IACtB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,8CAA8C,EAAE,KAAK,EAAE,CAAC,EAAE;QACzE,qCAAqC;QACrC,OAAO;IACT;AACF;AASO,eAAe,oBACpB,IAAY,EACZ,UAAmB,EACnB,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,IAAI;QACF,MAAM,SAAS,cAAc;QAC7B,MAAM,QAAQ,MAAM,OAAO,cAAc,CAAC,MAAM,QAAQ;QACxD,OAAO,SAAS;IAClB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,mDAAmD,EAAE,KAAK,EAAE,CAAC,EAAE;QAC9E,OAAO;IACT;AACF;AASO,eAAe,sBACpB,IAAY,EACZ,UAAmB,EACnB,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX,OAAO;IACT;IAEA,IAAI;QACF,MAAM,SAAS,cAAc;QAC7B,MAAM,UAAU,MAAM,OAAO,qBAAqB,CAAC,MAAM,QAAQ;QACjE,OAAO,WAAW;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,qDAAqD,EAAE,KAAK,EAAE,CAAC,EAAE;QAChF,OAAO;IACT;AACF;AAQO,SAAS,aACd,UAAkB,EAClB,SAAiB,EACjB,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,IAAI;QACF,OAAO,OAAO,CAAC;YACb;YACA,OAAO;YACP;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,wCAAwC,EAAE,UAAU,EAAE,CAAC,EAAE;IAC1E;AACF;AAOO,SAAS,aACd,UAAkB,EAClB,UAAgC;IAEhC,MAAM,SAAS;IACf,IAAI,CAAC,QAAQ;QACX;IACF;IAEA,IAAI;QACF,OAAO,QAAQ,CAAC;YACd;YACA;QACF;IACF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,yCAAyC,EAAE,WAAW,EAAE,CAAC,EAAE;IAC5E;AACF;AAMO,eAAe;IACpB,IAAI,eAAe;QACjB,MAAM,cAAc,QAAQ;QAC5B,gBAAgB;IAClB;AACF","debugId":null}},
    {"offset": {"line": 527, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/lib/featureFlags.ts"],"sourcesContent":["/**\n * Feature Flags Middleware\n * \n * Provides centralized feature flag management with caching.\n * Supports both client-side and server-side flag checks.\n */\n\nimport { isFeatureEnabled as clientIsFeatureEnabled } from \"./posthog/client\";\nimport { getFeatureFlag as serverGetFeatureFlag } from \"./posthog/server\";\n\n/**\n * Feature flag constants\n * Use these constants instead of string literals to avoid typos\n */\nexport const FEATURE_FLAGS = {\n  SPARK_BETA: \"spark-beta\",\n  MUSE_AI: \"muse-ai\",\n  ORBIT_EXPERIMENTAL: \"orbit-experimental\",\n  VAULT_ENHANCED: \"vault-enhanced\",\n  KLUTR_GLOBAL_DISABLE: \"klutr-global-disable\", // Kill switch\n} as const;\n\nexport type FeatureFlag = typeof FEATURE_FLAGS[keyof typeof FEATURE_FLAGS];\n\n/**\n * Cache entry for feature flags\n */\ninterface CacheEntry {\n  value: boolean;\n  timestamp: number;\n}\n\n/**\n * In-memory cache for feature flags\n * Key format: `flag:${flag}:${userId || 'anonymous'}`\n * TTL: 5 minutes (300000ms)\n */\nconst flagCache = new Map<string, CacheEntry>();\nconst CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n\n/**\n * Check if a cached value is still valid\n */\nfunction isCacheValid(entry: CacheEntry): boolean {\n  return Date.now() - entry.timestamp < CACHE_TTL;\n}\n\n/**\n * Get cache key for a flag and user\n */\nfunction getCacheKey(flag: string, userId?: string): string {\n  return `flag:${flag}:${userId || \"anonymous\"}`;\n}\n\n/**\n * Get cached flag value\n */\nfunction getCachedValue(flag: string, userId?: string): boolean | null {\n  const key = getCacheKey(flag, userId);\n  const entry = flagCache.get(key);\n\n  if (entry && isCacheValid(entry)) {\n    return entry.value;\n  }\n\n  // Remove expired entry\n  if (entry) {\n    flagCache.delete(key);\n  }\n\n  return null;\n}\n\n/**\n * Set cached flag value\n */\nfunction setCachedValue(flag: string, userId: string | undefined, value: boolean): void {\n  const key = getCacheKey(flag, userId);\n  flagCache.set(key, {\n    value,\n    timestamp: Date.now(),\n  });\n}\n\n/**\n * Check if a feature flag is enabled\n * Uses caching to reduce PostHog API calls\n * \n * @param flag - Feature flag key (use FEATURE_FLAGS constants)\n * @param userId - User ID for personalized flags (optional)\n * @param useServer - Force server-side check (default: auto-detect)\n * @returns Promise that resolves to true if flag is enabled, false otherwise\n */\nexport async function featureEnabled(\n  flag: string,\n  userId?: string,\n  useServer?: boolean\n): Promise<boolean> {\n  // Check kill switch first (always check this flag)\n  if (flag !== FEATURE_FLAGS.KLUTR_GLOBAL_DISABLE) {\n    const killSwitchEnabled = await featureEnabled(\n      FEATURE_FLAGS.KLUTR_GLOBAL_DISABLE,\n      userId,\n      useServer\n    );\n    if (killSwitchEnabled) {\n      // Kill switch is enabled - disable all features\n      return false;\n    }\n  }\n\n  // Check cache first\n  const cached = getCachedValue(flag, userId);\n  if (cached !== null) {\n    return cached;\n  }\n\n  // Determine if we should use server-side or client-side check\n  const isServer = useServer ?? typeof window === \"undefined\";\n\n  let enabled = false;\n\n  try {\n    if (isServer) {\n      // Server-side check\n      enabled = await serverGetFeatureFlag(flag, userId);\n    } else {\n      // Client-side check\n      enabled = await clientIsFeatureEnabled(flag);\n    }\n\n    // Cache the result\n    setCachedValue(flag, userId, enabled);\n\n    // Log flag checks for experimental users (when flag returns true)\n    if (enabled && userId) {\n      console.log(`[Feature Flag] \"${flag}\" enabled for user: ${userId}`);\n    }\n\n    return enabled;\n  } catch (error) {\n    console.error(`[Feature Flag] Error checking flag \"${flag}\":`, error);\n    // Fail closed: return false on error\n    return false;\n  }\n}\n\n/**\n * Clear the feature flag cache\n * Useful for testing or when flags need to be refreshed immediately\n */\nexport function clearFeatureFlagCache(): void {\n  flagCache.clear();\n}\n\n/**\n * Clear cache for a specific flag and user\n */\nexport function clearFeatureFlagCacheFor(flag: string, userId?: string): void {\n  const key = getCacheKey(flag, userId);\n  flagCache.delete(key);\n}\n\n"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;AAED;AACA;;;AAMO,MAAM,gBAAgB;IAC3B,YAAY;IACZ,SAAS;IACT,oBAAoB;IACpB,gBAAgB;IAChB,sBAAsB;AACxB;AAYA;;;;CAIC,GACD,MAAM,YAAY,IAAI;AACtB,MAAM,YAAY,IAAI,KAAK,MAAM,YAAY;AAE7C;;CAEC,GACD,SAAS,aAAa,KAAiB;IACrC,OAAO,KAAK,GAAG,KAAK,MAAM,SAAS,GAAG;AACxC;AAEA;;CAEC,GACD,SAAS,YAAY,IAAY,EAAE,MAAe;IAChD,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC,EAAE,UAAU,aAAa;AAChD;AAEA;;CAEC,GACD,SAAS,eAAe,IAAY,EAAE,MAAe;IACnD,MAAM,MAAM,YAAY,MAAM;IAC9B,MAAM,QAAQ,UAAU,GAAG,CAAC;IAE5B,IAAI,SAAS,aAAa,QAAQ;QAChC,OAAO,MAAM,KAAK;IACpB;IAEA,uBAAuB;IACvB,IAAI,OAAO;QACT,UAAU,MAAM,CAAC;IACnB;IAEA,OAAO;AACT;AAEA;;CAEC,GACD,SAAS,eAAe,IAAY,EAAE,MAA0B,EAAE,KAAc;IAC9E,MAAM,MAAM,YAAY,MAAM;IAC9B,UAAU,GAAG,CAAC,KAAK;QACjB;QACA,WAAW,KAAK,GAAG;IACrB;AACF;AAWO,eAAe,eACpB,IAAY,EACZ,MAAe,EACf,SAAmB;IAEnB,mDAAmD;IACnD,IAAI,SAAS,cAAc,oBAAoB,EAAE;QAC/C,MAAM,oBAAoB,MAAM,eAC9B,cAAc,oBAAoB,EAClC,QACA;QAEF,IAAI,mBAAmB;YACrB,gDAAgD;YAChD,OAAO;QACT;IACF;IAEA,oBAAoB;IACpB,MAAM,SAAS,eAAe,MAAM;IACpC,IAAI,WAAW,MAAM;QACnB,OAAO;IACT;IAEA,8DAA8D;IAC9D,MAAM,WAAW,aAAa,kDAAkB;IAEhD,IAAI,UAAU;IAEd,IAAI;QACF,IAAI,UAAU;YACZ,oBAAoB;YACpB,UAAU,MAAM,IAAA,4IAAoB,EAAC,MAAM;QAC7C,OAAO;YACL,oBAAoB;YACpB,UAAU,MAAM,IAAA,8IAAsB,EAAC;QACzC;QAEA,mBAAmB;QACnB,eAAe,MAAM,QAAQ;QAE7B,kEAAkE;QAClE,IAAI,WAAW,QAAQ;YACrB,QAAQ,GAAG,CAAC,CAAC,gBAAgB,EAAE,KAAK,oBAAoB,EAAE,QAAQ;QACpE;QAEA,OAAO;IACT,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,CAAC,oCAAoC,EAAE,KAAK,EAAE,CAAC,EAAE;QAC/D,qCAAqC;QACrC,OAAO;IACT;AACF;AAMO,SAAS;IACd,UAAU,KAAK;AACjB;AAKO,SAAS,yBAAyB,IAAY,EAAE,MAAe;IACpE,MAAM,MAAM,YAAY,MAAM;IAC9B,UAAU,MAAM,CAAC;AACnB","debugId":null}},
    {"offset": {"line": 641, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/lib/posthog/mcp.ts"],"sourcesContent":["/**\n * PostHog MCP Integration Helper\n * \n * This module provides utilities to work with PostHog via MCP server.\n * When MCP tools are available, they will be used automatically.\n * Falls back to REST API if MCP is not configured.\n */\n\nimport { FEATURE_FLAGS } from \"@/lib/featureFlags\";\nimport { createDefaultFeatureFlags as createViaAPI } from \"./api\";\n\n/**\n * Create default feature flags using MCP server (if available) or REST API (fallback)\n * \n * This function will attempt to use MCP tools if the PostHog MCP server is configured.\n * Otherwise, it falls back to the REST API implementation.\n */\nexport async function createDefaultFeatureFlagsViaMCP(): Promise<void> {\n  // Check if MCP tools are available\n  // In a real MCP setup, you would check for available MCP tools here\n  // For now, we'll use the REST API as fallback\n  \n  console.log(\"[PostHog MCP] Attempting to create flags via MCP server...\");\n  \n  try {\n    // TODO: When MCP server is configured, use MCP tools here\n    // Example (pseudo-code):\n    // if (mcpToolsAvailable) {\n    //   await mcp.posthog.createFeatureFlag({ key: FEATURE_FLAGS.SPARK_BETA, ... });\n    // } else {\n    //   await createViaAPI();\n    // }\n    \n    // For now, fall back to REST API\n    console.log(\"[PostHog MCP] MCP server not detected, using REST API fallback\");\n    await createViaAPI();\n  } catch (error) {\n    console.error(\"[PostHog MCP] Error creating flags:\", error);\n    throw error;\n  }\n}\n\n/**\n * Get the list of default flags to create\n * This can be used by MCP tools or other integrations\n */\nexport function getDefaultFlags() {\n  return [\n    {\n      key: FEATURE_FLAGS.SPARK_BETA,\n      name: \"Spark Beta\",\n      description: \"Beta access to Spark feature\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.MUSE_AI,\n      name: \"Muse AI\",\n      description: \"Muse AI feature access\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.ORBIT_EXPERIMENTAL,\n      name: \"Orbit Experimental\",\n      description: \"Experimental Orbit view feature\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.VAULT_ENHANCED,\n      name: \"Vault Enhanced\",\n      description: \"Enhanced vault features\",\n      active: false,\n    },\n    {\n      key: FEATURE_FLAGS.KLUTR_GLOBAL_DISABLE,\n      name: \"Klutr Global Disable\",\n      description: \"Global kill switch - disables all experimental features when enabled\",\n      active: false,\n    },\n  ];\n}\n\n/**\n * Instructions for using MCP server to create flags\n * \n * When PostHog MCP server is configured, you can ask the AI:\n * \"Create all the default PostHog feature flags\"\n * \n * The AI will use MCP tools to create:\n * - spark-beta\n * - muse-ai\n * - orbit-experimental\n * - vault-enhanced\n * - klutr-global-disable\n */\nexport const MCP_INSTRUCTIONS = `\nTo create PostHog feature flags via MCP server:\n\n1. Ensure PostHog MCP server is configured in Cursor settings\n2. Ask the AI: \"Create all the default PostHog feature flags\"\n3. The AI will use MCP tools to create each flag\n\nDefault flags to create:\n${getDefaultFlags().map(f => `- ${f.key}: ${f.name}`).join('\\n')}\n`;\n\n"],"names":[],"mappings":"AAAA;;;;;;CAMC;;;;;;;;AAED;AACA;;;AAQO,eAAe;IACpB,mCAAmC;IACnC,oEAAoE;IACpE,8CAA8C;IAE9C,QAAQ,GAAG,CAAC;IAEZ,IAAI;QACF,0DAA0D;QAC1D,yBAAyB;QACzB,2BAA2B;QAC3B,iFAAiF;QACjF,WAAW;QACX,0BAA0B;QAC1B,IAAI;QAEJ,iCAAiC;QACjC,QAAQ,GAAG,CAAC;QACZ,MAAM,IAAA,oJAAY;IACpB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uCAAuC;QACrD,MAAM;IACR;AACF;AAMO,SAAS;IACd,OAAO;QACL;YACE,KAAK,sIAAa,CAAC,UAAU;YAC7B,MAAM;YACN,aAAa;YACb,QAAQ;QACV;QACA;YACE,KAAK,sIAAa,CAAC,OAAO;YAC1B,MAAM;YACN,aAAa;YACb,QAAQ;QACV;QACA;YACE,KAAK,sIAAa,CAAC,kBAAkB;YACrC,MAAM;YACN,aAAa;YACb,QAAQ;QACV;QACA;YACE,KAAK,sIAAa,CAAC,cAAc;YACjC,MAAM;YACN,aAAa;YACb,QAAQ;QACV;QACA;YACE,KAAK,sIAAa,CAAC,oBAAoB;YACvC,MAAM;YACN,aAAa;YACb,QAAQ;QACV;KACD;AACH;AAeO,MAAM,mBAAmB,CAAC;;;;;;;;AAQjC,EAAE,kBAAkB,GAAG,CAAC,CAAA,IAAK,CAAC,EAAE,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,MAAM;AACjE,CAAC","debugId":null}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///Users/lee/Noteornope/app/api/posthog/setup-flags/route.ts"],"sourcesContent":["import { NextResponse } from \"next/server\";\nimport { createDefaultFeatureFlags } from \"@/lib/posthog/api\";\nimport { createDefaultFeatureFlagsViaMCP } from \"@/lib/posthog/mcp\";\n\n/**\n * API Route to create default feature flags in PostHog\n * \n * POST /api/posthog/setup-flags\n * \n * Creates all default feature flags defined in FEATURE_FLAGS if they don't exist.\n * Requires POSTHOG_PERSONAL_API_KEY and POSTHOG_PROJECT_ID environment variables.\n * \n * This endpoint attempts to use MCP server if available, otherwise falls back to REST API.\n * \n * Query parameters:\n * - ?useMCP=true - Force use of MCP server (if available)\n * - ?useAPI=true - Force use of REST API (default fallback)\n * \n * This is a one-time setup endpoint. You can call it after deploying to create\n * all the feature flags programmatically.\n */\nexport async function POST(request: Request) {\n  try {\n    // Optional: Add authentication/authorization here\n    // For now, this is open - you may want to add a secret check\n    \n    const url = new URL(request.url);\n    const useMCP = url.searchParams.get(\"useMCP\") === \"true\";\n    \n    if (useMCP) {\n      await createDefaultFeatureFlagsViaMCP();\n    } else {\n      await createDefaultFeatureFlags();\n    }\n\n    return NextResponse.json(\n      {\n        success: true,\n        message: \"Feature flags created successfully\",\n      },\n      { status: 200 }\n    );\n  } catch (error) {\n    console.error(\"[PostHog Setup] Error:\", error);\n    \n    return NextResponse.json(\n      {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n      },\n      { status: 500 }\n    );\n  }\n}\n\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAmBO,eAAe,KAAK,OAAgB;IACzC,IAAI;QACF,kDAAkD;QAClD,6DAA6D;QAE7D,MAAM,MAAM,IAAI,IAAI,QAAQ,GAAG;QAC/B,MAAM,SAAS,IAAI,YAAY,CAAC,GAAG,CAAC,cAAc;QAElD,IAAI,QAAQ;YACV,MAAM,IAAA,0JAA+B;QACvC,OAAO;YACL,MAAM,IAAA,oJAAyB;QACjC;QAEA,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,SAAS;QACX,GACA;YAAE,QAAQ;QAAI;IAElB,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,0BAA0B;QAExC,OAAO,+QAAY,CAAC,IAAI,CACtB;YACE,SAAS;YACT,OAAO,iBAAiB,QAAQ,MAAM,OAAO,GAAG;QAClD,GACA;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}